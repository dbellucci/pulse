Pulse is a small framework for building network prober and collect response time. Right now there 
are two available prober: ICMP and HTTP but more are coming soon and little effort is required
to build new one from scratch. 



Example ICMP Prober:

ICMP.pulse(:target => '192.168.1.1', :count =>5, :round_trip => 5, :delta => 0.5) do |probe|	
	probe.on_fail do |echo|
		Pulse::STDERR.report echo
	end

	probe.on_pulse do |echo|
		Pulse::STDOUT.report echo
	end
end


:count         stop after sending number pulse
:round_trip    waiting time for next pulse 
:delta         discard pulse if latency differ by at most delta


Example HTTP Prober:

HTTP.pulse(:target => 'http://localhost/', :count =>5, :round_trip => 5) do |probe|
	probe.on_fail do |echo|
		Pulse::STDERR.report "#{echo} not alive"
	end

	probe.on_pulse do |echo|
		Pulse::STDOUT.report echo
	end
end


A real HTTP Prober should take care of HTTP Response as well. Let'say we want to say alive!
if and only if strings 'works' is contained on HTTP response (body) message:


HTTP.pulse(:target => 'http://localhost/', :count =>5, :round_trip => 5) do |probe|
	probe.grep 'works'

	probe.on_fail do |echo|
		Pulse::STDERR.report "#{echo} not alive"
	end

	probe.on_pulse do |echo|
		Pulse::STDOUT.report echo
	end
end



To collect round-trip time values pulse provides a SQLite3 Mixin module called Pulse::DB:

Pulse::DB::open('HTTP_pulse.sqlite')

HTTP.pulse(:target => 'http://localhost/', :count =>5, :round_trip => 5) do |probe|
	probe.grep 'works'

	probe.on_fail do |echo|
		Pulse::STDERR.report "#{echo} not alive"
	end

	probe.on_pulse do |echo|
		[Pulse::STDOUT, Pulse::DB].each do |r|
			r.report echo
		end
	end
end


Hit ctrl-c when you want to stop probeing. The consistency of the Database is guaranteed 
by an at_exit{ } charged to close DB.


As you can see there is a bin/pulse:

belch@graal:~/git/pulse# RUBYLIB=./lib bin/pulse -h
Usage: pulse [options]
Options:
    -t, --target <target>            target host
    -c, --count <number>             stop after sending number pulse
    -r, --roundtrip <seconds>        waiting time for next pulse 
    -d, --delta <seconds>            discard pulse if latency differ by at most delta
    -w, --write <filename>           sqlite filename
    -p, --probe <name>               one of icmp or http
HTTP Probe Specific Options:
    -g, --grep <regexp>              regexp to match inside each line of http(s) response
    -h, --help                       Show this message

which works quite well as a pulse swiss knife:

belch@graal:~/git/pulse# RUBYLIB=./lib bin/pulse -t 'http://localhost' -c 5 -w http -p http -g 'works'
pulse from host:http://localhost id:0 rtt:0.001801
pulse from host:http://localhost id:1 rtt:0.003447
pulse from host:http://localhost id:2 rtt:0.003329
pulse from host:http://localhost id:3 rtt:0.003172
pulse from host:http://localhost id:4 rtt:0.002782
belch@graal:~/git/pulse# 

;)


TODO:
* Use event-machine
* Handle multiple targets at once
 
